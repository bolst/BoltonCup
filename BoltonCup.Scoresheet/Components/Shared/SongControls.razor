@using SpotifyAPI.Web

@inject SpotifyService Spotify
@inject NavigationManager Navigation
@inject IDialogService DialogService
@inject IBCData BCData
@inject ISnackbar Snackbar

@if (_loading)
{
    <MudProgressCircular Size="Size.Small" Color="Color.Secondary" Indeterminate />
}
else
{
    if (Authenticated)
    {
        <MudStack AlignItems="AlignItems.Center" Row>
            
            @if (_currentTrack is not null)
            {
                var track = _currentTrack.Item as FullTrack;
                var artists = string.Join(", ", track.Artists.Select(x => x.Name));

                <MudStack AlignItems="AlignItems.End" Spacing="0">
                    <MudText Typo="Typo.body2">@track.Name.FixedLengthWithEllipsis(50)</MudText>
                    <MudText Typo="Typo.caption" Style="font-size: 0.5rem">@artists.FixedLengthWithEllipsis(50)</MudText>
                </MudStack>

                <MudImage Src="@track.Album.Images.FirstOrDefault().Url" Height="40"/>
            }

            <MudButtonGroup OverrideStyles="false">
                @if (_currentTrack is not null)
                {
                    @if (_currentTrack.IsPlaying)
                    {
                        <MudIconButton OnClick="OnPause" Icon="@Icons.Material.Filled.PauseCircle" Color="Color.Tertiary"/>
                    }
                    else
                    {
                        <MudIconButton OnClick="OnPlay" Icon="@Icons.Material.Filled.PlayCircle" Color="Color.Tertiary"/>
                    }

                    <MudIconButton OnClick="OnSkipForward" Icon="@Icons.Material.Filled.SkipNext" Color="Color.Tertiary"/>
                }
                else
                {
                    <MudTooltip Text="Reload Spotify data">
                        <MudIconButton OnClick="(() => RefreshState())" Color="Color.Error" Icon="@Icons.Material.Filled.Refresh"/>
                    </MudTooltip>
                }

                @if (_user!.DisplayName == "nicbolton")
                {
                    <MudIconButton OnClick="ShowChoosePlaylistDialog" Icon="@Icons.Material.Filled.PlaylistAddCircle" Color="Color.Warning"/>
                }

                @if (_queue.Any())
                {
                    <MudMenu Icon="@Icons.Material.Filled.QueueMusic" Color="Color.Info">
                        <MudDropContainer T="IPlayableItem" Items="_queue.Take(8)" ItemsSelector="@((_,__) => true)" ItemDropped="OnReorderQueue">
                            <ChildContent>
                                <MudList T="IPlayableItem" Color="Color.Info" Class="d-flex flex-column mud-height-full" Dense>
                                    <MudDropZone T="IPlayableItem" Identifier="yooo" AllowReorder />
                                </MudList>
                            </ChildContent>
                            <ItemRenderer>
                                @if (context is FullTrack item)
                                {
                                    <MudListItem Value="context" Text="@item.Name">
                                        <MudStack AlignItems="AlignItems.Center" Row>
                                            <MudImage Src="@item.Album.Images.FirstOrDefault()?.Url" Height="30"/>
                                            <MudText>@item.Name.FixedLengthWithEllipsis(30)</MudText>
                                        </MudStack>
                                    </MudListItem>
                                }
                            </ItemRenderer>
                        </MudDropContainer>
                    </MudMenu>
                }

                

                <MudMenu Icon="@Icons.Material.Filled.Person" Color="Color.Info" Dense>
                    <MudMenuItem Icon="@Icons.Material.Filled.Person" Label="@_user.DisplayName"/>
                    <MudMenuItem OnClick="Logout" Icon="@Icons.Material.Filled.Logout" IconColor="Color.Error" Label="Logout"/>
                </MudMenu>

            </MudButtonGroup>
        </MudStack>
    }
    else
    {
        <MudButton OnClick="Login" StartIcon="@_spotifySvg" Variant="Variant.Filled" Color="Color.Success">Login</MudButton>
    }
}



@code {
    
    private bool _loading;
    private int _volume;
    private PrivateUser? _user;
    private CurrentlyPlayingContext? _currentTrack;
    private List<IPlayableItem> _queue = [];
    

    private const string _spotifySvg = @"<svg role=""img"" viewBox=""0 0 24 24"" xmlns=""http://www.w3.org/2000/svg""><title>Spotify</title><path d=""M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z""/></svg>";

    private bool Authenticated => _user is not null;
    
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _loading = true;
            StateHasChanged();

            var spotify = await GetClient(true);
            if (spotify is not null)
                _user = await spotify.UserProfile.Current();
            
            await RefreshState(true);
            
            _loading = false;
            StateHasChanged();
        }
    }


    private async Task<SpotifyClient?> GetClient(bool suppress = false)
    {
        var spotify = await Spotify.GetClientAsync();
        if (spotify is not null) return spotify;

        if (!suppress) Snackbar.Add("Unable to fetch Spotify client", Severity.Error);
        return null;
    }


    private async Task RefreshState(bool suppress = false)
    {
        var spotify = await GetClient(suppress);
        if (spotify is null) return;
        
        _currentTrack = await spotify.Player.GetCurrentPlayback();
        if (_currentTrack is null)
        {
            if (!suppress) Snackbar.Add("No track is playing! Make sure Spotify is open and a song is playing/paused.", Severity.Info);
            return;
        }

        _queue = (await spotify.Player.GetQueue()).Queue;
        
        InvokeAsync(StateHasChanged);
    }
    

    private void Login()
    {
        var uri = Spotify.LoginRequestUri.ToString();
        
        Navigation.NavigateTo(uri);
    }


    private async Task Logout()
    {
        await Spotify.LogoutAsync();
        Navigation.NavigateTo(Navigation.Uri, true);
    }


    private async Task OnPause()
    {
        try
        {
            var spotify = await GetClient();
            if (spotify is null) return;
            
            await spotify.Player.PausePlayback();
        }
        catch (Exception e)
        {
            Console.WriteLine($"From OnPause:\n{e.Message}");
        }
        
        await RefreshState();
    }
    
    
    private async Task OnPlay()
    {
        try
        {
            var spotify = await Spotify.GetClientAsync();
            if (spotify is null) return;
            
            await spotify.Player.ResumePlayback();
        }
        catch (Exception e)
        {
            Console.WriteLine($"From OnPlay:\n{e.Message}");
        }

        await RefreshState();
    }


    private async Task OnSkipForward()
    {           
        var spotify = await GetClient();
        if (spotify is null) return;

        try
        {
            await spotify.Player.SkipNext();

            // TODO: fuck with this n test more
            await Task.Delay(100);
            
            // if offset exists skip to it
            var song = await spotify.Player.GetCurrentPlayback();
            if (song.Item is not FullTrack track)
                return;

            var offset = await BCData.GetSongOffsetAsync(track.Id);
            if (offset == 0)
                return;

            int offsetMs = offset * 1000;
            await spotify.Player.SeekTo(new PlayerSeekToRequest(offsetMs));
        }
        catch (Exception e)
        {
            Console.WriteLine($"OnSkipForward: {e.Message}");
        }
        
        await RefreshState();
    }



    private async Task ShowChoosePlaylistDialog()
    {
        var spotify = await GetClient();
        if (spotify is null) return;

        var playlists = await spotify.Playlists.CurrentUsers();

        var parameters = new DialogParameters<ChoosePlaylistDialog>
        {
            { x => x.Playlists, playlists.Items }
        };
        
        var dialog = await DialogService.ShowAsync<ChoosePlaylistDialog>("Choose Playlist", parameters);
        var result = await dialog.Result;

        if (result?.Data is FullPlaylist)
        {
            var playlist = result.Data as FullPlaylist;

            int offset = 0;
            IEnumerable<FullTrack> tracks = [];

            while (true)
            {
                var request = new PlaylistGetItemsRequest
                {
                    Offset = offset
                };
                offset += 100;

                var playlistTracks = await spotify.Playlists.GetItems(playlist.Id, request);

                var newTracks = playlistTracks.Items?
                    .Where(x => x.Track is FullTrack)
                    .Select(x => x.Track as FullTrack)
                    .ToList();
                if (newTracks is null || !newTracks.Any()) break;
                
                tracks = tracks.Concat(newTracks)!;
            }
                
            await BCData.SetBCPlaylistSongsAsync(tracks);
        }
    }



    private async Task OnReorderQueue(MudItemDropInfo<IPlayableItem> dropItem)
    {
        if (dropItem.Item is null) return;

        // var oldIndex = _queue.IndexOf(dropItem.Item);
        // var newIndex = dropItem.IndexInZone;
        //
        // (_queue[oldIndex], _queue[newIndex]) = (_queue[newIndex], _queue[oldIndex]);
        // await BCData.SwapSongOrdersAsync(_queue[oldIndex], _queue[newIndex]);
    }
    
}